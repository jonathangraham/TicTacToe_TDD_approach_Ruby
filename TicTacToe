class Board
	attr_reader :board

	def initialize(grid_size)
		@board = Array.new(grid_size * grid_size, ' ')
	end 

	def update_board(position, letter)
		@board[position] = letter
	end

	def empty_space?(position)
		@board[position] == ' '
	end

	def tie?()
		@board.count(' ') == 0
	end

	def rows()
		rows = []
		matrix = @board.each_slice(Math.sqrt(@board.length)).to_a
		matrix.each do |innerArray|
			rows << innerArray
		end
	end

	def columns()
		rows.transpose
	end

	def diaganols()
		n = rows.length
		diaganols = [first_diaganol(n), second_diaganol(n)]
	end

	def first_diaganol(n)
		first_diaganol = []
		a = 0
		n.times do
			first_diaganol << rows[a][a]
			a = a + 1
		end
		first_diaganol
	end

	def second_diaganol(n)
		second_diaganol = []
		a = 0
		b = n - 1
		n.times do
			second_diaganol << rows[a][b]
			a = a + 1
			b = b - 1
		end
		second_diaganol
	end

	def potential_winning_lines()
		rows | columns | diaganols 
	end

	def win?(marker)
		potential_winning_lines().map do |innerArray|
			innerArray.map do |e|
				e == marker
			end.count(true) == innerArray.length
		end.include? true
	end

	def game_end?()
		marker = marker_just_played()
		win?(marker) || tie?()
	end

	def marker_just_played()
		if (@board.length - @board.count(' '))%2 == 0
			'O'
		else
			'X'
		end
	end

	def marker_to_play_next()
		marker_just_played() == 'O' ? 'X' : 'O'
	end

	def available_spaces()
		@board.each_index.select{|i| @board[i] == ' '}
	end

end

class SequentialAI

	def determine_move(board)
		board.available_spaces.first
	end
end


class RandomAI


	def generate_random_position(board)
		rand(board.board.length)
	end

	def determine_move(board)
		position = generate_random_position(board)
		until board.empty_space?(position) || board.tie? do
			position = generate_random_position(board)
		end
		position
	end
end

class NegamaxAI

	def determine_move(board)
		player = board.marker_to_play_next
		depth = 1
		negamax(board, player, depth)
		return @negamax_move
	end

	def negamax(board, current_marker, depth)
		opponent_marker = opponent(current_marker)
    	if board.game_end?
      		return score(board, current_marker, opponent_marker, depth)
    	else
      		best_rank = -999
      		board.available_spaces.each do |space|
        		board.update_board(space, current_marker)
        		rank = -negamax(board, opponent_marker, depth + 1 )
       			board.update_board(space, ' ')
	       			if rank > best_rank
	         			best_rank = rank
	         			if depth == 1
	         				@negamax_move = space
	         			end
					end
     		end
     		return best_rank
		end
	end

	def score(board, current_marker, opponent_marker, depth)
		if board.win?(current_marker)
			return 100 - depth
		elsif board.win?(opponent_marker)
		    return -(100 - depth)
		else
		    return 0
		end
	end

	def opponent(marker)
		marker == "X" ? "O" : "X"
	end
end

class Game

	def generate_move(board, play_type)
		play_type.new.determine_move(board)
	end

	def make_move(board, play_type)
		board.update_board(generate_move(board, play_type), board.marker_to_play_next)
	end

	def play_new_game(size, player1, player2)
		board = Board.new(size)
		players = [player1, player2].cycle
		until board.game_end? do
			make_move(board, players.next)
		end
		board
	end
end
