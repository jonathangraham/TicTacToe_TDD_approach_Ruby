class Board
	attr_reader :board, :index_board

	def initialize(grid_size)
		elements = grid_size * grid_size
		@board = Array.new(elements, ' ')
		@index_board = Array(0..(elements - 1))
	end

	def update_board(position, letter)
		@board[position] = letter
	end

	def empty_space?(position)
		@board[position] == ' '
	end

	def tie?()
		@board.count(' ') == 0
	end

	def rows()
		rows = @board.each_slice(Math.sqrt(@board.length)).to_a
	end

	def columns()
		rows.transpose
	end

	def diaganols()
		n = rows.length
		diaganols = [first_diaganol(n), second_diaganol(n)]
	end

	def first_diaganol(n)
		first_diaganol = []
		a = 0
		n.times do
			first_diaganol << rows[a][a]
			a = a + 1
		end
		first_diaganol
	end

	def second_diaganol(n)
		second_diaganol = []
		a = 0
		b = n - 1
		n.times do
			second_diaganol << rows[a][b]
			a = a + 1
			b = b - 1
		end
		second_diaganol
	end

	def potential_winning_lines()
		rows | columns | diaganols 
	end

	def win?(marker)
		potential_winning_lines().map do |innerArray|
			innerArray.map do |e|
				e == marker
			end.count(true) == innerArray.length
		end.include? true
	end

	def game_end?()
		marker = marker_just_played()
		win?(marker) || tie?()
	end

	def marker_just_played()
		if (@board.length - @board.count(' '))%2 == 0
			'O'
		else
			'X'
		end
	end

	def marker_to_play_next()
		marker_just_played() == 'O' ? 'X' : 'O'
	end

	def available_spaces()
		@board.each_index.select{|i| @board[i] == ' '}
	end

	def valid_space?(position)
		@board[position] == ' '
	end


end

class SequentialAI

	attr_reader :name

	def initialize()
		@name = SequentialAI
	end

	def determine_move(board)
		board.available_spaces.first
	end
end


class RandomAI

	attr_reader :name

	def initialize()
		@name = RandomAI
	end

	def generate_random_position(board)
		rand(board.board.length)
	end

	def determine_move(board)
		position = generate_random_position(board)
		until board.empty_space?(position) || board.tie? do
			position = generate_random_position(board)
		end
		position
	end
end

class NegamaxAI

	attr_reader :name

	def initialize()
		@name = NegamaxAI
	end

	def determine_move(board)
		player = board.marker_to_play_next
		depth = 1
		negamax(board, player, depth)
		return @negamax_move
	end

	def negamax(board, current_marker, depth)
		opponent_marker = opponent(current_marker)
    	if board.game_end?
      		return score(board, current_marker, opponent_marker, depth)
    	else
      		best_rank = -999
      		board.available_spaces.each do |space|
        		board.update_board(space, current_marker)
        		rank = -negamax(board, opponent_marker, depth + 1 )
       			board.update_board(space, ' ')
	       			if rank > best_rank
	         			best_rank = rank
	         			if depth == 1
	         				@negamax_move = space
	         			end
					end
     		end
     		return best_rank
		end
	end

	def score(board, current_marker, opponent_marker, depth)
		if board.win?(current_marker)
			return 100 - depth
		elsif board.win?(opponent_marker)
		    return -(100 - depth)
		else
		    return 0
		end
	end

	def opponent(marker)
		marker == "X" ? "O" : "X"
	end
end

class Human

	attr_reader :ui
	attr_reader :name

	def initialize(ui, name)
		@ui = ui
		@name = name
	end

	def determine_move(board)
		response = ui.get_user_response
		position = response.to_i
		until board.valid_space?(position)
			ui.print_valid_space_error
			response = ui.get_user_response
			position = response.to_i 
		end
		position
	end
end

class Game

	attr_accessor :ui

	def initialize(ui)
		@ui = ui
	end

	def generate_move(board, play_type)
		play_type.determine_move(board)
	end

	def make_move(board, play_type)
		board.update_board(generate_move(board, play_type), board.marker_to_play_next)
	end

	def play_new_game(board, player1, player2)
		players = [player1, player2].cycle
		until board.game_end? do
			current_player = players.next
			ui.print_player_turn(current_player)
			ui.print_board(board.index_board)
			make_move(board, current_player)
			ui.print_board(board.board)
		end
		ui.print_result(board, current_player)
		board
	end

	def game_setup
		ui.ask_play?
		if ui.get_user_response == 'Y'
			board = board_setup
			player1 = player_setup(1)
			player2 = player_setup(1)
			play_new_game(board, player1, player2)
		else
			exit
		end
		game_setup
	end

	def board_setup
		ui.ask_board_size
		board_size = ui.get_user_response.to_i
		Board.new(board_size)
	end

	def player_setup(number)
		ui.ask_player_type(number)
		player_type = ui.get_user_response
		if player_type == 'H'
			ui.ask_player_name
			name = ui.get_user_response
			Human.new(ui, name)
		elsif player_type == 'C'
			NegamaxAI.new
		else
			player_setup(number)
		end
	end

end

class ConsoleReadWrite

	def print_line(str)
		puts str
	end

	def read_line
		gets.chomp.upcase
	end

end

class UI

	attr_reader :interface

	def initialize(interface)
		@interface = interface
	end

	def ask_play?()
		@interface.print_line("Press Y to play new game.")
	end

	def ask_board_size()
		@interface.print_line("Board size? (eg type '3' for a 3x3 board)")
	end

	def ask_player_type(number)
		@interface.print_line("Player #{number}: Human(H) or Computer(C)?")
	end

	def ask_player_name
		@interface.print_line("What is your name?")
	end

	def ask_computer_level
		@interface.print_line("Easy(1), Moderate(2) or Hard(3)?")
	end

	def get_user_response
		@interface.read_line
	end

	def print_board(board)
		lines = board.each_slice(Math.sqrt(board.length)).to_a
		lines.each do |line|
			@interface.print_line("#{line.join('|')}")
		end
	end

	def print_player_turn(player)
		@interface.print_line("#{player.name} to go next. Where do you want to play")
	end

	def print_valid_space_error()
		@interface.print_line("Please enter a valid space")
	end

	def print_result(board, player)
		if board.win?(board.marker_just_played)
			@interface.print_line("#{player.name} wins!")
		else
			@interface.print_line("Game tied")
		end
	end
end


interface = ConsoleReadWrite.new
ui = UI.new(interface)
game = Game.new(ui)
game.game_setup


