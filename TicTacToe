def generate_new_board
	[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']
end

def update_board(board, position, letter)
	board[position] = letter
	board
end

def empty_space?(position, board)
	board[position] == ' '
end

def tie?(board)
	board.count(' ') == 0
end

def potential_winning_lines(board)
		[[board[0],board[1],board[2]],[board[3],board[4],board[5]],[board[6],board[7],board[8]],[board[0],board[3],board[6]],[board[1],board[4],board[7]],[board[2],board[5],board[8]],[board[0],board[4],board[8]],[board[2],board[4],board[6]]] 
end

def win?(board, marker)
	#marker = current_marker(board)
	potential_winning_lines(board).map do |innerArray|
			innerArray[0] == innerArray[1] && innerArray[1] == innerArray[2] && innerArray[0] == marker  
	end.include? true
end

def game_end?(board)
	marker = current_marker(board)
	win?(board, marker) || tie?(board)
end

def competitor_to_play_next(board)
	if board.count(' ')%2 == 1
		'X'
	else
		'O'
	end
end

def make_move(board, level)
	update_board(board, determine_move(board, level), competitor_to_play_next(board))
end

def determine_move(board, level)
	if level == 'sequential'
		next_available_space(board)
	elsif level == 'random'
		generate_random_move(board) 		
	end
end

def next_available_space(board)
	board.index(' ')
end

def play_new_game(level)
	board = generate_new_board
	until game_end?(board) do
		make_move(board, level)
	end
	board
end

def current_marker(board)
	competitor_to_play_next(board) == 'O' ? 'X' : 'O'
end

def generate_random_position
	rand(9)
end

def generate_random_move(board)
	position = generate_random_position
	until empty_space?(position, board) || board.count(' ') == 0 do
		position = generate_random_position
	end
	position
end

def generate_negamax_move(board)
	current_marker = opponent(current_marker)
	depth = 1
	negamax(board, current_marker, depth)
	return @negamax_move
end

def negamax(board, current_marker, depth)
		opponent_marker = competitor_to_play_next(board)
    	if game_end?(board)
      		return score(board, current_marker, opponent_marker, depth)
    	else
      		best_rank = -999
      		available_spaces(board).each do |space|
        		update_board(board, space, current_marker)
        		rank = -negamax(board, opponent_marker, depth + 1 )
       			update_board(board, space, ' ')
	       			if rank > best_rank
	         			best_rank = rank
	         			if depth == 1
	         				@negamax_move = space
	         			end
					end
     		end
     		return best_rank
		end
end

def score(board, current_marker, opponent_marker, depth)
	if win?(board, current_marker)
		return 100 - depth
	elsif win?(board, opponent_marker)
	    return -(100 - depth)
	else
	    return 0
	end
end

def available_spaces(board)
	board.each_index.select{|i| board[i] == ' '}
end

def opponent(marker)
	marker == "X" ? "O" : "X"
end

