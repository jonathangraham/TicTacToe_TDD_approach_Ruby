class Board
	attr_reader :board

	def initialize(board)
		@board = board
	end 

	def update_board(position, letter)
		@board[position] = letter
	end

	def empty_space?(position)
		@board[position] == ' '
	end

	def tie?()
		@board.count(' ') == 0
	end

	def potential_winning_lines()
		[[@board[0],@board[1],@board[2]],
		[@board[3],@board[4],@board[5]],
		[@board[6],@board[7],@board[8]],
		[@board[0],@board[3],@board[6]],
		[@board[1],@board[4],@board[7]],
		[@board[2],@board[5],@board[8]],
		[@board[0],@board[4],@board[8]],
		[@board[2],@board[4],@board[6]]] 
	end

	def win?(marker)
		potential_winning_lines().map do |innerArray|
			innerArray[0] == innerArray[1] && innerArray[1] == innerArray[2] && innerArray[0] == marker  
		end.include? true
	end

	def game_end?()
		marker = marker_just_played()
		win?(marker) || tie?()
	end

	def marker_just_played()
		if @board.count(' ')%2 == 0
			'X'
		else
			'O'
		end
	end

	def marker_to_play_next()
		marker_just_played() == 'O' ? 'X' : 'O'
	end

	def available_spaces()
		@board.each_index.select{|i| @board[i] == ' '}
	end

end

class SequentialAI

	def determine_move(board)
		board.available_spaces.first
	end
end


class RandomAI


	def generate_random_position
		rand(9)
	end

	def determine_move(board)
		position = generate_random_position
		until board.empty_space?(position) || board.tie? do
			position = generate_random_position
		end
		position
	end
end

class NegamaxAI

	def determine_move(board)
		player = board.marker_to_play_next
		depth = 1
		negamax(board, player, depth)
		return @negamax_move
	end

	def negamax(board, current_marker, depth)
		opponent_marker = opponent(current_marker)
    	if board.game_end?
      		return score(board, current_marker, opponent_marker, depth)
    	else
      		best_rank = -999
      		board.available_spaces.each do |space|
        		board.update_board(space, current_marker)
        		rank = -negamax(board, opponent_marker, depth + 1 )
       			board.update_board(space, ' ')
	       			if rank > best_rank
	         			best_rank = rank
	         			if depth == 1
	         				@negamax_move = space
	         			end
					end
     		end
     		return best_rank
		end
	end

	def score(board, current_marker, opponent_marker, depth)
		if board.win?(current_marker)
			return 100 - depth
		elsif board.win?(opponent_marker)
		    return -(100 - depth)
		else
		    return 0
		end
	end

	def opponent(marker)
		marker == "X" ? "O" : "X"
	end
end

class Game

	def generate_move(board, play_type)
		play_type.new.determine_move(board)
	end

	def make_move(board, play_type)
		board.update_board(generate_move(board, play_type), board.marker_to_play_next)
	end

	def play_new_game(play_type)
		board = Board.new([' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '])
		until board.game_end? do
			make_move(board, play_type)
		end
		board
	end
end
