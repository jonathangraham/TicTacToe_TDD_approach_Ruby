require_relative 'TTT.rb'
require 'minitest/autorun'

def replace_initial_board_for_tests(board, test_board)
	test_board.each_with_index do |e, i|
		board.update_board(i, e)
	end
end

class TestBoard < Minitest::Test

	def test_create_new_board_3x3
		board = Board.new(3, 3)
		assert_equal([' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], board.board)
	end

	def test_create_new_board_4x4
		board = Board.new(4, 4)
		assert_equal([' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], board.board)
	end

	def test_rows
		board = Board.new(3, 3)
		replace_initial_board_for_tests(board, ["0", "1", "2", "3", "4", "5", "6", "7", "8"])
		assert_equal([["0", "1", "2"], ["3", "4", "5"], ["6", "7", "8"]], board.rows)
	end

	def test_columns
		board = Board.new(3, 3)
		replace_initial_board_for_tests(board, ["0", "1", "2", "3", "4", "5", "6", "7", "8"])
		assert_equal([["0", "3", "6"], ["1", "4", "7"], ["2", "5", "8"]], board.columns)
	end

	def test_diaganols
		board = Board.new(3, 3)
		replace_initial_board_for_tests(board, ["0", "1", "2", "3", "4", "5", "6", "7", "8"])
		assert_equal([["0", "4", "8"], ["2", "4", "6"]], board.diaganols)
	end

	def test_diaganols_4x4
		board = Board.new(4, 4)
		replace_initial_board_for_tests(board, ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15'])
		assert_equal([["0", "5", "10", '15'], ["3", "6", "9", '12']], board.diaganols)
	end

	def test_potantial_winning_lines
		board = Board.new(3, 3)
		replace_initial_board_for_tests(board, ["0", "1", "2", "3", "4", "5", "6", "7", "8"])
		assert_equal([['0', '1', '2'], ['3', '4', '5'], ['6', '7', '8'], ["0", "3", "6"], ["1", "4", "7"], ["2", "5", "8"],["0", "4", "8"], ["2", "4", "6"]], board.potential_winning_lines)
	end

	def test_potantial_winning_lines_2
		board = Board.new(5, 5)
		test_board = Array (0..24)
		replace_initial_board_for_tests(board, test_board)		
		number_winning_lines = board.potential_winning_lines
		assert_equal(12, number_winning_lines.length)
	end

	def test_empty_space_returns_true_with_empty_space?
		board = Board.new(3, 3)
		assert_equal(true, board.empty_space?(0))
	end

	def test_occupied_space_returns_true_with_empty_space?
		board = Board.new(3, 3)
		replace_initial_board_for_tests(board, ['X', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '])
		assert_equal(false, board.empty_space?(0))
	end

	def test_empty_board_returns_false_with_tie?
		board = Board.new(4, 4)
		assert_equal(false, board.tie?)
	end

	def test_partial_full_board_returns_false_with_tie?
		board = Board.new(3, 3)
		replace_initial_board_for_tests(board, ['X', ' ', 'O', 'X', ' ', ' ', ' ', ' ', ' '])
		assert_equal(false, board.tie?)
	end

	def test_full_board_returns_true_with_tie?
		board = Board.new(3, 3) 
		replace_initial_board_for_tests(board, ['X', 'X', 'O', 'O', 'O', 'X', 'X', 'O', 'X'])
		assert_equal(true, board.tie?)
	end

	def test_empty_board_returns_false_for_X_win?
		board = Board.new(4, 4)
		assert_equal(false, board.win?('X'))
	end

	def test_3_in_row_winning_board_for_X_returns_true_for_X_win?
		board = Board.new(3, 3) 
		replace_initial_board_for_tests(board, ['X', 'X', 'X', ' ', ' ', ' ', ' ', ' ', ' '])
		assert_equal(true, board.win?('X'))
	end

	def test_2_in_row_winning_board_for_X_returns_true_for_X_win?
		board = Board.new(3, 2) 
		replace_initial_board_for_tests(board, ['O', 'X', 'X', ' ', ' ', ' ', ' ', ' ', ' '])
		assert_equal(true, board.win?('X'))
	end

	def test_2_non_sequential_in_row_returns_false_for_X_win?
		board = Board.new(3, 2) 
		replace_initial_board_for_tests(board, ['X', 'O', 'X', ' ', ' ', ' ', ' ', ' ', ' '])
		assert_equal(false, board.win?('X'))
	end

	def test_3_in_row_when_2_needed_returns_true_for_X_win?
		board = Board.new(3, 2) 
		replace_initial_board_for_tests(board, ['X', 'X', 'X', ' ', ' ', ' ', ' ', ' ', ' '])
		assert_equal(true, board.win?('X'))
	end

	def test_winning_board_for_X_returns_false_for_O_win?
		board = Board.new(3, 3) 
		replace_initial_board_for_tests(board, ['X', 'X', 'X', ' ', ' ', ' ', ' ', ' ', ' '])
		assert_equal(false, board.win?('O'))
	end

	def test_winning_board_for_O_returns_true_for_O_win?
		board = Board.new(4, 4) 
		replace_initial_board_for_tests(board, ['O', ' ', ' ', ' ', ' ', 'O', ' ', ' ', ' ', ' ', 'O', ' ', ' ', ' ', ' ', 'O'])
		assert_equal(true, board.win?('O'))
	end

	def test_winning_board_for_O_returns_true_for_O_win?
		board = Board.new(4, 3) 
		replace_initial_board_for_tests(board, [' ', ' ', ' ', ' ', ' ', 'O', ' ', ' ', ' ', ' ', 'O', ' ', ' ', ' ', ' ', 'O'])
		assert_equal(true, board.win?('O'))
	end

	def test_non_winning_board_for_O_returns_false_for_O_win?
		board = Board.new(4, 3) 
		replace_initial_board_for_tests(board, ['O', ' ', ' ', ' ', ' ', 'X', ' ', ' ', ' ', ' ', 'O', ' ', ' ', ' ', ' ', 'O'])
		assert_equal(false, board.win?('O'))
	end

	def test_marker_to_play_first_is_X
		board = Board.new(3, 3)
		assert_equal('X', board.marker_to_play_next)
	end

	def test_marker_to_play_first_is_X_2
		board = Board.new(4, 4)
		assert_equal('X', board.marker_to_play_next)
	end

	def test_next_sequential_space_available_empty_board
		board = Board.new(3, 3)
		assert_equal(0, board.available_spaces.first)
	end

	def test_next_sequential_space_available_empty_board_2
		board = Board.new(13, 13)
		assert_equal(0, board.available_spaces.first)
	end

	def test_next_sequential_space_available_partial_board
		board = Board.new(4, 4) 
		replace_initial_board_for_tests(board, ['O', 'O', ' ', ' ', ' ', 'X', ' ', ' ', ' ', ' ', 'X', ' ', ' ', ' ', ' ', 'X'])
		assert_equal(2, board.available_spaces.first)
	end

	def test_available_spaces
		board = Board.new(3, 3) 
		replace_initial_board_for_tests(board, ['X', 'O', 'X', 'O', 'X', 'O', 'X', ' ', ' '])
		assert_equal([7,8], board.available_spaces)
	end

	def test_available_spaces_2
		board = Board.new(2, 2) 
		replace_initial_board_for_tests(board, ['X', ' ', 'X', ' '])
		assert_equal([1,3], board.available_spaces)
	end

	def test_valid_space
		board = Board.new(3, 3) 
		replace_initial_board_for_tests(board, ['X', 'O', 'X', 'O', 'X', 'O', 'X', ' ', ' '])
		assert_equal(true, board.valid_space?(8))
		assert_equal(false, board.valid_space?(0))
		assert_equal(false, board.valid_space?(10))
	end
end

class TestAI < Minitest::Test
	def test_generate_position_with_sequential_rules
		board = Board.new(3, 3) 
		replace_initial_board_for_tests(board, ['X', 'O', 'X', ' ', ' ', ' ', ' ', ' ', ' '])
		position = SequentialAI.new.determine_move(board)
		assert_equal(3, position)
	end

	def test_generate_random_position
		board = Board.new(2, 2) 
		position = RandomAI.new.generate_random_position(board)
		assert_equal(true, [0,1,2,3].include?(position))
	end	

	def test_generate_position_with_randomAI_single_option
		board = Board.new(3, 3) 
		replace_initial_board_for_tests(board, ['X', 'O', 'X', 'O', ' ', 'O', 'X', 'X', 'O'])
		position = RandomAI.new.determine_move(board)
		assert_equal(4, position)
	end

	def test_generate_position_with_randomAI_multiple_options
		board = Board.new(2, 2)
		replace_initial_board_for_tests(board, ['X', ' ', ' ', 'O'])
		position = RandomAI.new.determine_move(board)
		assert_equal(true, [1,2].include?(position))
	end

	def test_generate_position_with_negamaxAI_single_option
		board = Board.new(3, 3)
		replace_initial_board_for_tests(board, ['X', 'O', 'X', 'O', ' ', 'O', 'X', 'X', 'O'])
		position = NegamaxAI.new.determine_move(board)
		assert_equal(4, position)
	end

	def test_generate_position_with_negamexAI_move_to_win_1
		board = Board.new(3, 3)
		replace_initial_board_for_tests(board, ['X', ' ', 'O', 'X', 'O', 'X', ' ', ' ', 'O'])
		ai = NegamaxAI.new
		position = ai.determine_move(board)
		assert_equal(6, position)
	end

	def test_generate_position_with_negamexAI_move_to_win_2
		board = Board.new(4, 4)
		replace_initial_board_for_tests(board, ['X', 'X', 'X', ' ', 'O', 'X', 'O', 'X', ' ', ' ', ' ', ' ', 'O', 'O', ' ', 'O'])
		position = NegamaxAI.new.determine_move(board)
		assert_equal(3, position)
	end

	def test_generate_position_with_negamexAI_move_to_win_3
		board = Board.new(3, 3)
		replace_initial_board_for_tests(board, [' ', 'X', ' ', 'X', 'O', 'X', ' ', ' ', 'O'])
		position = NegamaxAI.new.determine_move(board)
		assert_equal(0, position)
	end

	def test_generate_position_with_negamexAI_block_opponent_win
		board = Board.new(4, 4)
		replace_initial_board_for_tests(board, ['X', 'X', 'X', ' ', 'O', 'X', 'O', 'X', ' ', ' ', ' ', ' ', 'O', 'O', 'X', 'O'])
		position = NegamaxAI.new.determine_move(board)
		assert_equal(3, position)
	end

	def test_generate_position_with_negamexAI_block_opponent_win_1
		board = Board.new(3, 3)
		replace_initial_board_for_tests(board, ['X', 'O', 'X', ' ', 'O', ' ', ' ', ' ', ' '])
		position = NegamaxAI.new.determine_move(board)
		assert_equal(7, position)
	end

	def test_generate_position_with_negamexAI_block_opponent_win_2
		board = Board.new(3, 3)
		replace_initial_board_for_tests(board, ['X', 'O', ' ', 'O', 'X', 'X', ' ', ' ', ' '])
		position = NegamaxAI.new.determine_move(board)
		assert_equal(8, position)
	end

	def test_generate_position_with_negamexAI_win_instead_block_1
		board = Board.new(3, 3)
		replace_initial_board_for_tests(board, ['X', ' ', 'O', 'X', ' ', 'O', ' ', ' ', ' '])
		position = NegamaxAI.new.determine_move(board)
		assert_equal(6, position)
	end

	def test_generate_position_with_negamexAI_create_fork
		board = Board.new(3, 3)
		replace_initial_board_for_tests(board, ['O', ' ', ' ', ' ', ' ', ' ', 'X', 'O', 'X'])
		position = NegamaxAI.new.determine_move(board)
		assert_equal(2, position)
	end

	def test_generate_position_with_negamexAI_block_fork
		board = Board.new(3, 3)
		replace_initial_board_for_tests(board, [' ', ' ', 'X', ' ', 'O', ' ', 'X', ' ', ' '])
		position = NegamaxAI.new.determine_move(board)
		assert_equal(1, position)
	end
end

class TestGame < Minitest::Test
	
	def test_sequential_game_move_determination
		board = Board.new(3, 3)
		replace_initial_board_for_tests(board, ['X', 'O', 'X', ' ', ' ', ' ', ' ', ' ', ' '])
		mock_console_read_write = MockConsoleReadWrite.new
		ui = UI.new(mock_console_read_write)
		game = Game.new(ui)
		assert_equal(3, game.generate_move(board, SequentialAI.new))
	end

	def test_random_game_move_determination
		board = Board.new(3, 3)
		replace_initial_board_for_tests(board, ['X', 'O', 'X', ' ', ' ', 'O', 'X', 'O', 'X'])
		mock_console_read_write = MockConsoleReadWrite.new
		ui = UI.new(mock_console_read_write)
		game = Game.new(ui)
		assert_equal(true, [3,4].include?(game.generate_move(board, RandomAI.new)))
	end

	def test_negamax_game_move_determination
		board = Board.new(3, 3)
		replace_initial_board_for_tests(board, [' ', ' ', 'X', ' ', 'O', ' ', 'X', ' ', ' '])
		mock_console_read_write = MockConsoleReadWrite.new
		ui = UI.new(mock_console_read_write)
		game = Game.new(ui)
		assert_equal(1, game.generate_move(board, NegamaxAI.new))
	end

	def test_make_sequential_move
		board = Board.new(3, 3)
		replace_initial_board_for_tests(board, ['X', 'O', 'X', ' ', ' ', ' ', ' ', ' ', ' '])
		mock_console_read_write = MockConsoleReadWrite.new
		ui = UI.new(mock_console_read_write)
		game = Game.new(ui)
		game.make_move(board, SequentialAI.new)
		assert_equal(['X', 'O', 'X', 'O', ' ', ' ', ' ', ' ', ' '], board.board)
	end	

	def test_make_random_move
		board = Board.new(3, 3)
		replace_initial_board_for_tests(board, ['X', 'O', 'X', ' ', ' ', ' ', ' ', ' ', ' '])
		mock_console_read_write = MockConsoleReadWrite.new
		ui = UI.new(mock_console_read_write)
		game = Game.new(ui)
		game.make_move(board, RandomAI.new)
		assert_equal(5, board.board.count(' '))
	end	

	def test_make_negamax_move
		board = Board.new(3, 3)
		replace_initial_board_for_tests(board, [' ', ' ', 'X', ' ', 'O', ' ', 'X', ' ', ' '])
		mock_console_read_write = MockConsoleReadWrite.new
		ui = UI.new(mock_console_read_write)
		game = Game.new(ui)
		game.make_move(board, NegamaxAI.new)
		assert_equal([' ', 'O', 'X', ' ', 'O', ' ', 'X', ' ', ' '], board.board)
	end

	def test_play_game_sequential_moves
		board = Board.new(3, 3)
		mock_console_read_write = MockConsoleReadWrite.new
		ui = UI.new(mock_console_read_write)
		game = Game.new(ui)
		game_result = game.play_new_game(board, SequentialAI.new, SequentialAI.new)
		assert_equal(['X', 'O', 'X', 'O', 'X', 'O', 'X', ' ', ' '], game_result.board)
	end

	def test_play_game_random_moves
		board = Board.new(3, 3)
		mock_console_read_write = MockConsoleReadWrite.new
		ui = UI.new(mock_console_read_write)
		game = Game.new(ui)
		game_result = game.play_new_game(board, RandomAI.new, RandomAI.new)
		assert_equal(true, [0,1,2,3,4].include?(game_result.board.count(' ')))
	end

	def test_play_game_random_and_negamax_moves
		board = Board.new(3, 3)
		mock_console_read_write = MockConsoleReadWrite.new
		ui = UI.new(mock_console_read_write)
		game = Game.new(ui)
		game_result = game.play_new_game(board, RandomAI.new, NegamaxAI.new)
		assert_equal(true, game_result.game_end?)
	end

	def test_play_game_sequential_and_random
		output = MockConsoleReadWrite.new
		ui = UI.new(output)
		board = Board.new(3, 3)
		game = Game.new(ui)
		final_board = game.play_new_game(board, SequentialAI.new, RandomAI.new)
		assert_equal(true, final_board.game_end?)
	end
end

class MockConsoleReadWrite
	attr_accessor :lines_printed
	attr_accessor :lines_to_read

	def initialize
		@lines_printed =[]
		@lines_to_read = []
	end

	def print_line(str)
		@lines_printed << str
	end

	def read_line
		str = "read_line called"
		@lines_to_read << str
	end
end


class TestUI < Minitest::Test

	def test_ask_play?
		mock_console_read_write = MockConsoleReadWrite.new
		play = UI.new(mock_console_read_write)
		array_lines_printed = play.ask_play?
		assert_equal(mock_console_read_write.lines_printed[0], array_lines_printed[0])
		assert_equal(1, array_lines_printed.length)
	end

	def test_get_response
		mock_console_read_write = MockConsoleReadWrite.new
		play = UI.new(mock_console_read_write)
		array_lines_read = play.get_user_response
		assert_equal(mock_console_read_write.lines_to_read[0], array_lines_read[0])		
	end

	def test_print_initial_3x3_board
		mock_console_read_write = MockConsoleReadWrite.new
		board = Board.new(3, 3)
		play = UI.new(mock_console_read_write)
		assert_equal(3, play.print_board(board.board).length)
	end

	def test_print_4x4_board_with_index_positions
		mock_console_read_write = MockConsoleReadWrite.new
		board = Board.new(4, 4)
		play = UI.new(mock_console_read_write)
		assert_equal(4, play.print_board(board.index_board).length)
	end

	def test_print_player_to_go_next
		mock_console_read_write = MockConsoleReadWrite.new		
		play = UI.new(mock_console_read_write)
		assert_equal(mock_console_read_write.lines_printed, play.print_player_turn(NegamaxAI))
	end

end
